EXPECTED DELIVERABLES (4+1 model - https://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf) 
----------------------------------------------------------------------------------------------------------
The architecture will follow the 4+1 architecture model which splits the architecture into 4 different views that pertain to different stakeholders(much like a building's architecture can be viewed from electrical, plumbing, structural, etc ):
1. Logical view - the functionality and object model of the system(classes, packages, interfaces).Basically what developers create based on business requirements. UML diagrams : class and state. Perspective of:end-users (functionality that is provided to end users).
2. Development(implementation view) - modules and components of the system. Basically what is generated by the build output(JAR, WAR, executables etc). UML diagrams: component and package. Perspective of : developers.
3. Process view - interprocess communication with focus on runtime behavior (concurrency, distribution, integration, performance, and scalability). UML diagrams : sequence, communication, activity. Perspective of : integrators. Describe processes and inter-process communication
4. Deployment(physical) view - machines, processes and networking between them. UML diagrams : deployment. Perspective of : system engineer. Describes the mapping of software to hardware and reflects it's distributed aspects
5. Scenarios (use case view) - sequences of interactions between objects and between processes. UML diagrams: scenario, interaction, maybe also use case?

FUNCTIONAL REQUIREMENTS (USER STORIES)
----------------------------------
1. As a Consumer I want to place an Order so that I can have dinner
2. As a Consumer I want to be able to check the status of my Order
3. As a Consumer I want to be able to see a history of my Orders
4. As a Consumer I want to be able to see the list of Restaurants in my area
5. As a Consumer I want to be able to see the menu of a Restaurant

4. As a Restaurant I want to accept an Order so that I can prepare it
5. As a Restaurant I want to be able to charge(authorize) the Consumer's card
6. As a Restaurant I want to be able to assign the Order to a Courier

7. As a Courier I want to deliver an Order so that I can get my fee.
8. As a Courier I want to be able to charge my fee from the Restaurant.


NON-FUNCTIONAL REQUIREMENTS (https://www.altexsoft.com/blog/non-functional-requirements/)
-----------------------------------------------------------------------------------------

1. Performance - Max response time when application is under heavy load (more than 80% concurrent) = 3s ; Max response time when under normal load (at max 80% concurrent users) = 1s ; Max transaction throughput per second(request per second) = 800 tx/second (assuming the total number of users is 1000)
		 https://www.ibm.com/docs/en/aix/7.1?topic=implementation-performance-requirements-documentation
		 https://www.nngroup.com/articles/response-times-3-important-limits/
2. Scalability - is the ability to support the required quality of service as the system load increases without changing the system - should be able to meet the performance requirements wihtout changes for an anual users base increase of 10%  in the next 1-5 years. 
		 https://www.modernanalyst.com/Resources/Articles/tabid/115/ID/4968/Non-Functional-Requirements-Scalability.aspx
		 https://www.softwaretestinghelp.com/what-is-scalability-testing/)
3. *Availability(expressed as the degree to which the system is operable) - 0.99 (99% of the time available) - calculated as uptime/downtime (23,76h/24h which allows for a weekly downtime of 1.68h)
							      https://www.bmc.com/blogs/reliability-vs-availability/
4. *Reliability(expressed as probability of failure-free operation of software in a specified environment for a specified time) - ensures the integrity and consistency of the application and all its transactions. - 95%/day probability that the system will not encounter any critical failuire in a day

5. *Maintainability(expressed as probability of repair during some time) - is the ability to correct flaws in the existing functionality without impacting other components of the system - 75% probability of repair in a day, which means there is a 75% chance that the component will be fixed in a day

6. *Manageability(expressed as no of staff hours per month required to perform system configuration changes)- ability to change the system configuration to improve the QoS dynamically without changing the system. 

7. *Extensibility(no metrics available) - ability to add additional functionality or modify existing functionality without impacting existing system functionality.

8. Security - the ability to ensure that the system cannot be compromised

9. Testability - the degree to which a system can be tested effectively and efficiently. The system should have 95% coverage by unit tests. Also, integration tests should be present and every main scenario should be covered by end to end tests.

10. Deployability - deployment should be a straightforward low risk push button event

Non-functional requirements marked with * can be hard to define in calculative terms especially at the beginning of the project, since the system needs to be operational in order to calculate them.
Expressing requirements as calculative terms at the beginning is just a way to specify the ideal that we need to achieve, however there is no good way to test this.
Out of all the nonfunctional requirements marked with * that have calculative terms , the availability can be included in SLA.The others can be quite risky.


GENERAL ARCHITECTURE DECISIONS
------------------------------
While microservice is an architectural style at system level, each microservice will use hexagonal architectural style internally (class diagram from logical view will be represented as such).
Libraries should be used, as long as each microservice team is the sole responsible for maintaining their own libraries. A library with DTO's should not be a problem, as it does not contain functionality.
Also, if functionality is needed to be shared, should not be a big issue because there will be many versions of the same library, so not every service is required to change.


DECOMPOSTION
------------

1. Define system operations(represents external requests that are defined in term of domain model which starts from user stories and scenarios)

S1)Define high-level domain model (derived from the nouns in user stories and scenarios) - Consumer, Order, Restaurant, Courier (Menu, MenuItem, Address etc can be derived by breaking the user stories into scenarios).
This domain model will be expaned as we expand user stories into scenarios that provide more detail, but this is useful for identifying the services. Also each microservice will have its own domain model.

S2)Define operations(derived from the verbs in user stories)
Consumer operations - register(), placeOrder(), checkOrderStatus(), checkConsumerOrders(), checkRestaurantsInMyArea(),checkRestaurantMenu()
Restaurant operations - acceptOrder(), chargeConsumerCreditCard()
Courier operations - register(), startOrderDelivery(), finishOrderDelivery(), chargeFee()


Detailed system operations


register - parameter Consumer
         - returns consumerId 
         - preconditions - data needs to be valid and card needs to be charged
         - postconditions - the consumer card is charged a fee that will be reverted and the consumer is created 

placeOrder - parameter Order
           - returns orderId
           - precoditions - the customer exists and is able to make orders
			  - the order line items exist and correspond to restaurant menu items
			  - the order can be prepared by the restaurant
                          - a courier is available for delivery
	   - postconditions - the consumer's card was charged for the order total
                            - an order is created in PENDING state

checkOrderStatus - parameter orderId
                 - returns status of the order
                 - preconditions - the order needs to be an existing order
                 - postconditions - none

checkConsumerOrders  - parameter customerId
                     - returns a list of orders
                     - preconditions - the custmer needs to be a valid existing customer
                     - postcondtions - none

checkRestaurantsInMyArea - parameter geolocation
                         - retuns a list of restaurants
			 - preconditions - a valid geolocation needs to be provided	
                         - postconditions - none

checkRestaurantMenu - parameter restaurantId
                    - returns a menu with it's items
                    - preconditions - the restaurant id needs to be from an existing opened restaurant
                    - postconditions - none

acceptOrder - parameter order
            - returns void
            - preconditions - the order is in status PENDING
			    - a courier is available for delivery
	    - postconditions - the status of the order is ACCEPTED
                             - the courier is assigned to deliver the order
                             - the order delivery time is updated

debitConsumerCreditCard - parameters are card details (card number,cvv, holder name) and amount to be charged
                 - returns payment
                 - preconditions - the card details point to a valid card
                                 - the amount to be charged is available on the card
		 - postconditions - the amount is charged from the credit card


register - parameter courier
         - returns courierId
         - preconditions - data is valid
         - postconditions - the courier is created

startOrderDelivery - parameters is order
                   - returns void
	           - preconditions - order is assigned to a courier and has status ACCEPTED
	           - postconditions - order is in status in DELIVERY	
		 	
finishOrderDelivery - parameters is order
                    - returns void
	            - preconditions - order is assigned to a courier and has status IN_DELIVERY
	            - postconditions - order is in status in DELIVERED

creditCourierFee(payCourierFee) - parameters courier bank account, fee amount
                 	        - returns payment
                                - preconditions - order is in status DELIVERED
                                                - courier's credit card is valid
	                        - postconditions - the courier's card is credited with the fee amount 		

2. Indentify services

Am ramas la 2.2.1 Identifying system operations


2.2.6


De facut 
1. diagrama cu flow pt register (include si api gateway)
2. vezi cu faci tranzactii cu messaging (3.3.7)
3. adauga axon pt saga
4. verifica cum faci saga cu axon

https://insart.com/fintech-cto-club/avoiding-the-pitfalls-of-distributed-transactions-with-sagas/
https://developer.axoniq.io/w/sagas-in-practice
https://stackoverflow.com/questions/58381498/is-it-possible-to-scale-axon-framework-without-axon-server-enterprise
https://www.ufried.com/blog/limits_of_saga_pattern/

For pp presentation
1. what is a saga and why we need it
2. problems with saga (lack of isolation and rollback)
3. how to solve the problems that saga provides(loack of isolation- semantic lock and other solutions, rollback-compensating trx than need to run in reverse order of the forward transactions (some trx execute in parallel so they are compensated in parallel))
4. transactional messaging (outbox)
5. types of sagas(orchestration and choreography)
6. message ordering and redelivery
7. saga state needs to be stored
8. how does a saga deal with a semantic lock introduced by the another saga ? fail the command or block ?
9. saga does not solve if a technical error occures during execution.maybe we can save the a status and resume when everything is back online?
10. why we should use async calls with messaging vs asyn calls with http or sync calls (3.4 using async messaging to improve availability)



Can axon saga be used without axon server and use kafka and mongodb instead?
https://docs.axoniq.io/reference-guide/extensions/kafka
https://github.com/marinkobabic/axon-kafka-example
Can spring cloudstream be used instead of axon saga?


Questions for Gartner about saga
1. How does saga mitigate technical issues? Let's say the message never reaches kafka